name: ECS Application Deployment

on:
  push:
    branches:
      # - main
      - release
  workflow_dispatch:

# Required for OIDC authentication to AWS
permissions:
  id-token: write
  contents: read

jobs:
  lint_and_scan:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install dependencies & Lint
        run: |
          npm install
          npm run lint || true # Allow failure but log results

      - name: Run TruffleHog Secret Scan
        uses: trufflesecurity/trufflehog@main
        with:
          path: ./
          base: ${{ github.event.before }}
          extra_args: --config .trufflehog.yaml || true # Allow failure but log results
    
  build_and_push:
    runs-on: ubuntu-latest
    needs: lint_and_scan # Only proceed if security/quality checks pass
    outputs:
        image_tag: ${{ steps.set_tag.outputs.TAG }}

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Set Image Tag
        id: set_tag
        # Uses the first 8 characters of the commit SHA as the unique tag
        run: echo "TAG=$(echo ${{ github.sha }} | cut -c 1-8)" >> $GITHUB_OUTPUT

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
            aws-region: ${{ vars.AWS_REGION }}
            # Assume a specific role for ECR and ECS deployment
            role-to-assume: ${{ secrets.AWS_ROLE }}

        # 2. Login to ECR
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

        # 3. Build Docker Image
      - name: Build and Tag Docker Image
        id: build-image
        env:
            ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
            ECR_REPOSITORY: ${{ vars.ECR_REPOSITORY_NAME }}
            IMAGE_TAG: ${{ steps.set_tag.outputs.TAG }}
        run: |
            docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
            docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest

        # 4. Push Docker Image to ECR
      - name: Push Docker Image to ECR
        env:
            ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
            ECR_REPOSITORY: ${{ vars.ECR_REPOSITORY_NAME }}
            IMAGE_TAG: ${{ steps.set_tag.outputs.TAG }}
        run: |
            echo "Pushing $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
            docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
            docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest

  deploy:
    runs-on: ubuntu-latest
    needs: build_and_push # Depends on successful image build
    environment: production

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

        # 1. Configure AWS Credentials (Needed again for this job's context)
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
            aws-region: ${{ vars.AWS_REGION }}
            role-to-assume: ${{ secrets.AWS_ROLE }}

        # 2. Download Task Definition JSON and insert the new image tag
      - name: Download and Render Task Definition
        id: render-task-definition
        uses: aws-actions/amazon-ecs-render-task-definition@v1
        with:

            task-definition: task-definition.json 
            # This must match the container name in the Task Definition HCL in Terraform
            container-name: nodejs-crud-app-container 
            image: ${{ steps.login-ecr.outputs.registry }}/${{ vars.ECR_REPOSITORY_NAME }}:${{ needs.build_and_push.outputs.image_tag }}

        # 3. Deploy the new Task Definition to the ECS Service
      - name: Deploy to ECS Service
        uses: aws-actions/amazon-ecs-deploy-task-definition@v1
        with:
            task-definition: ${{ steps.render-task-definition.outputs.task-definition }}
            service: ${{ secrets.ECS_SERVICE_NAME }}
            cluster: ${{ secrets.ECS_CLUSTER_NAME }}
            wait-for-service-stability: true # Wait for the zero-downtime update to complete